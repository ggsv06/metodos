# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HD5IkeFzJwW5mR70_PrwXvZVYZDtGVlA
"""

import numpy as np
import matplotlib.pyplot as plt

# ==============================================================================
# 1. IMPLEMENTAÇÃO DO ALGORITMO (Item A)
# ==============================================================================
def simular_montante(u, r, m0=0):
    """
    Calcula a evolução do montante m(k) baseado na recorrência:
    m(k+1) = (1+r) * (m(k) + u(k))
    """
    K = len(u)
    m = np.zeros(K + 1)
    m[0] = m0

    for k in range(K):
        # A recorrência dada no enunciado
        m[k+1] = (1 + r) * (m[k] + u[k])

    return m

# ==============================================================================
# 2. VALIDAÇÃO E TESTES SIMPLES (Gera dados para a Tabela do Item A)
# ==============================================================================
print("--- ITEM A: Validação ---")
u_teste = np.ones(5) * 100 # 5 depósitos de 100

# Cenário 1: Sem juros
m_teste1 = simular_montante(u_teste, r=0)
print(f"Cenário r=0 (Final): {m_teste1[-1]:.2f}") # Deve dar 500

# Cenário 2: Juros de 10%
m_teste2 = simular_montante(u_teste, r=0.10)
print(f"Cenário r=0.1 (Final): {m_teste2[-1]:.2f}") # Deve dar ~671.56
print("")

# ==============================================================================
# 3. COMPARAÇÃO E GRÁFICO (Item B)
# ==============================================================================
print("--- ITEM B: Comparação de Estratégias ---")
K_meses = 24
r_base = 0.01  # 1%

# Estratégia I: Aporte Único (10k no início, 0 depois)
u1 = np.zeros(K_meses)
m1 = simular_montante(u1, r_base, m0=10000)

# Estratégia II: Aporte Mensal (0 no início, 1k por mês)
u2 = np.ones(K_meses) * 1000
m2 = simular_montante(u2, r_base, m0=0)

# Geração do Gráfico (figura_prob1_b.png)
plt.figure(figsize=(8, 5))
plt.plot(np.arange(K_meses+1), m1, 'o--', label='Estratégia I (Único 10k)')
plt.plot(np.arange(K_meses+1), m2, 's-', label='Estratégia II (Mensal 1k)')
plt.title(f'Comparação de Estratégias (24 Meses, r={r_base*100}%)')
plt.xlabel('Mês (k)')
plt.ylabel('Montante Acumulado (R$)')
plt.legend()
plt.grid(True, alpha=0.3)
plt.savefig('figura_prob1_b.png')
print("Gráfico 'figura_prob1_b.png' gerado com sucesso.")

# Análise de Sensibilidade (Outras taxas pedidas no item b)
taxas = [0.005, 0.02] # 0.5% e 2.0%
for r in taxas:
    val1 = simular_montante(u1, r, m0=10000)[-1]
    val2 = simular_montante(u2, r, m0=0)[-1]
    print(f"Taxa {r*100}% -> Est. I: {val1:.2f} | Est. II: {val2:.2f}")
print("")

# ==============================================================================
# 4. CONFIRMAÇÃO TEÓRICA (Item C)
# ==============================================================================
print("--- ITEM C: Confirmação Numérica ---")
E = 10000
r = 0.01
K = 24

# Cálculo do p teórico (fórmula derivada na Transformada Z)
numerador = E * r * ((1 + r)**(K - 1))
denominador = ((1 + r)**K) - 1
p_teorico = numerador / denominador

print(f"Valor de p calculado teoricamente: {p_teorico:.4f}")

# Simulação com esse p exato
u_equiv = np.ones(K) * p_teorico
m_equiv = simular_montante(u_equiv, r, m0=0)

# Comparação final
final_I = m1[-1]        # Estratégia I (já calculada)
final_II_equiv = m_equiv[-1] # Estratégia II ajustada

print(f"Montante Final Estratégia I (10k):   {final_I:.2f}")
print(f"Montante Final Estratégia II (p={p_teorico:.2f}): {final_II_equiv:.2f}")

if abs(final_I - final_II_equiv) < 0.01:
    print(">> SUCESSO: Os valores convergem! A fórmula analítica está correta.")
else:
    print(">> ALERTA: Há divergência nos valores.")


# ==============================================================================
# EASTER EGG uhuuuuu :)
# Merry Christmas & Happy New Year!
# ==============================================================================